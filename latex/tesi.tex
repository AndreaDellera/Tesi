\documentclass[a4paper]{article}

\usepackage[T1]{fontenc} %
\usepackage[utf8]{inputenc} % 
\usepackage{mathptmx} % font in times new roman

\usepackage{cite}
\usepackage{harmony}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{margin=2cm}
\newcommand{\setmetera}[2]{\ensuremath{\genfrac{}{}{0pt}{}{#1}{#2}}} % \setmetera{4}{4} per scrivere il tempo 4/4
\begin{document}

\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here


\textsc{\LARGE Universit\`a degli studi di Trento}\\[0.8cm] % Name of your university/college
\textsc{\Large Corso di laurea in informatica}\\[0.8cm] % Major heading such as course name

\HRule\\[0.8cm]
{\huge \bfseries Music RNN}\\[0.4cm] % Title of your document
\HRule\\[2cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\begin{tabular}{ll}
Dellera \textsc{Andrea} & \makebox[2cm][r]{158365} \\
\end{tabular}
\end{flushleft}
\end{minipage}

\vfill % Fill the rest of the page with whitespace
{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise
\end{titlepage}

\newpage

\section{Introduzione}
%Il mondo della musica \`e sempre stato qualcosa di astratto, di impalpabile. Regge ormai da decenni la figura del rocker che, grazie alla sua chitarra, anima folle sempre pi\`u grandi e si oppone alle scelte del governo corrente. Un po' pi\`u in disuso \`e la figura del musicista in voga negli anni d'oro della musica classica, da Mozart lo scrittore maltrattato dalla vita a Beethoven che, nonostante la sordit\`a, riusc\`i a comporre un capolavoro come la \emph{sonata al chiaro di luna}.\\
%Ma il processo creativo che sta dietro alla stesura di un brano pu\`o essere riprodotto da un qualcosa che non pensa come un computer? Pu\`o un algoritmo, una tecnica di programmazione, portare una macchina a produrre delle melodie?\\
%Lo scopo di questa tesi \`e di creare delle melodie utilizzando una tecnica di machine learning per potare la macchina ad acquisire brani gi\`a scritti e successivamente creare delle melodie.\\
TODO

\newpage
\section{Codifica}
%Il primo passo per l'implementazione di questo obiettivo \`e la codifica delle note. Qui entrano in gioco vari parametri (sono stati presi in considerazione i pi\`u essenziali): 
Le note vengono estratte da partiture scritte in formato MusicXML e le features considerate sono cinque:\\
\begin{itemize}
\item[-]nome della nota;
\item[-]alterazione;
\item[-]durata;
\item[-]punto di valore;
\item[-]ottava.
\end{itemize}
Di queste cinque il nome e l'alterazione sono unite in un'unica codifica visto che sono strettamente correlate tra loro cos\`i come la durata e punto di valore.\\
\subsection{Codifica delle note}
Le note nel sistema europeo sono chiamate \emph{la, si, do, re, mi, fa, sol} che nel sistema americano corrispondono a \emph{A, B, C, D, E, F, G}; in questo scritto verr\`a utilizzato il secondo, perch\`e pi\`u compatto e sintetico.\\
Per codificare tutte le note servono almeno quattro bit, questo perch\`e oltre alle sette naturali riportate sopra abbiamo anche quelle alterate dai $\sharp$ e dai $\flat$. Va ricordato per\`o che introducendo entrambe le alterazioni nella codifica si hanno note ridondati dal punto di vista sonoro. Infatti se G $\sharp$ e A $\flat$ indicano due note diverse, perch\`e cambia la tonalit\`a in cui vengono usate, il suono che viene prodotto quando sono suonate \`e per\`o lo stesso. Ecco perch\`e nella codifica utilizzeremo solo il diesis.\\
\begin{table}[h]
\centering
\begin{tabular}{| l  c |}
\multicolumn {2}{c}{\textbf{Codifica}}\\
\hline
A& 0000\\\hline
A$\sharp$& 0001\\\hline
B& 0010\\\hline
C& 0011\\\hline
C$\sharp$& 0100\\\hline
D& 0101\\\hline
D$\sharp$& 0110\\\hline
E& 0111\\\hline
F& 1000\\\hline
F$\sharp$& 1001\\\hline
G& 1010\\\hline
G$\sharp$& 1011\\\hline
\end{tabular}
\end{table}

\subsection{Codifica della durata}
Per la durata della nota il ragionamento \`e analogo. 	La durata massima di una nota \`e \setmetera{4}{4} (\Ganz). Si trovano tutte nella forma $\frac{1}{2^n}$ dove $0\leq n \leq +\infty$. Convenzionalmente per\`o le prime tre della sequenza sono descritte come \setmetera{4}{4} (\Ganz), \setmetera{2}{4} (\Halb), \setmetera{1}{4} (\Vier).
Le durate che verranno codificate arriveranno fino ad \setmetera{1}{64}.\\
Come fatto precedentemente verr\`a assegnata una sequenza di bit ad ogni durata.\\
\begin{table}[h]
\renewcommand\arraystretch{1.4}
\centering
\begin{tabular}{| l  c |}
\multicolumn {2}{c}{\textbf{Codifica}}\\
\hline
\setmetera{4}{4}& 000\\\hline
\setmetera{2}{4}& 001\\\hline
\setmetera{1}{4}& 010\\\hline
\setmetera{1}{8}& 011\\\hline
\setmetera{1}{16}& 100\\\hline
\setmetera{1}{32}& 101\\\hline
\setmetera{1}{64}& 110\\\hline
\end{tabular}
\end{table}\\
Un'altra variabile che entra quando si parla di durata \`e il \emph{punto di valore} (\Pu). Questo strumento aumenta la durata della nota della sua met\`a e per codificarlo useremo un bit che sar\`a 0 se non c'\`e e 1 in caso contrario.\\

\subsection {Codifica dell'ottava}
In ci\`o che va a costituire una nota una parte importante \`e l'\emph{ottava}. L'ottava costituisce l'altezza della nota, un'offset rispetto a quella pi\`u bassa. Si pu\`o pensarla come una somma di $n * 12semitoni$ rispetto alla nota pi\`u bassa.
Anche qui la codifica che verr\`a seguita \`e binaria. Essendoci undici ottave, $C_{-1};...; C_9$, dovrebbero essere usati 4 bit per la rappresentazione ma, visto che le ottave $C_{-1}, C_0$ e $C_9$ non vengono praticamente mai utilizzate verranno usati tre bit per rappresentare le otto rimanenti.

\begin{table}[h]
\centering
\begin{tabular}{| l  c |}
\multicolumn {2}{c}{\textbf{Codifica}}\\
\hline
$C_1$& 000\\\hline
$C_2$& 001\\\hline
$C_3$& 010\\\hline
$C_4$& 011\\\hline
$C_5$& 100\\\hline
$C_6$& 101\\\hline
$C_7$& 110\\\hline
$C_8$& 111\\\hline
\end{tabular}
\end{table}

\subsection {Codifca delle pause}
Le pause sono uno strumento musicale molto comune, vengono utilizzate per dire ad uno strumento di non suonare. L'unico dato che portano \`e quello della durata, visto che non hanno una ottava di riferimento.
Verranno codificate con \emph{1111} nel campo di codifica della nota, in quanto denotano una nota inesistente

\subsection{Esempi di codifica}


\begin{table}[h]
\renewcommand\arraystretch{1.4}
\begin{tabular}{| c c |}
Do di \setmetera{4}{4}, della terza ottava:& 01100100000\\
Do di \setmetera{1}{4}, della terza ottava:& 01100100100\\
\end{tabular}
\end{table}

\newpage
\section{Rete neurale ricorrente}
\subsection{Cenni teorici}
TODO
\subsection{Numero di input}
\`E stato dichiarato nell'incipit che il tipo di rete utilizzato per il machine learning \`e una rete neurale ricorrente. Questo \`e vero ma, per approfondire meglio l'argomento, sono state utilizzate anche reti neurali semplici. La differenza tra le due \`e che nella prima tra i neuroni dell'hidden layer sono presenti dei percorsi con cicli mentre nella seconda no. 
Teoricamente ad una RNN basterebbe una sola nota in input per imparare una canzone intera, visto che ha memoria di quello che ha visto ed in che ordine lo ha visto, ma si \`e reso necessario ampliare l'input ad otto note (come si vede in ~\cite{todd1989}) perch\`e una sola non risultava sufficiente per limiti di hardware.
Con otto note in input la probabilit\`a che la rete indovini il target aumenta perch\`e rendiamo esplicita un pezzo di storia della canzone (le $N$ note precedenti al target).
Durante la fase di scrittura del codice \`e stata riscontrata una relazione tra il numero di note in input e la correttezza dell'output che conferma quanto detto; ovvero se come input si dava una sequenza composta solo da una sola nota questa riusciva a predirne correttamente solo un'altra come successiva. Se quindi ci si trovava nella situazione di una doppia scelta ecco che la rete non riusciva pi\`u a distinguere le due note.
Sempre facendo riferimento allo scritto citato sopra (~\cite{todd1989}) si legge che la rete creata era caratterizzata dall'avere otto note come input. Non c'\`e un modo per decidere in arbitrariamente il numero di note in input ma bisogna trovare un compromesso tra la quantit\`a di sequenze che si possono riconoscere e la complessit\`a del sistema.\\

\subsection{Tipo di rete utilizzata}
La rete neurale ricorrente \`e cos\`i composta:
\begin{itemize}
\item[-]1 layer di input con $Nnote*11$ neuroni;
\item[-]1 hidden layer con 10 neuroni;
\item[-]1 layer di output con 11 neuroni.
\end{itemize}
C'\`e una full connection tra il layer di input e l'hidden layer, tra l'hidden layer e il layer di output e tra l'hidden layer e se stesso. \footnote{I pesi che portano dal nodo $A$ al nodo $B$ possono essere diversi di quelli che portano dal nodo $B$ al nodo $A$}
La rete neurale non ricorrente \`e identica solo non presenta la connessione tra l'hidden layer e se stesso.

\section{Train della rete}
Per allenare la RNN \`e stato scelto l?algoritmo di BackPropagation, associato a Gradient Descent. 
%ed alla tecnica bold driver, che permette di aggiornare il valore del learning rate in base a come si comporta la rete durante il training. 
L'aggiornamento dei pesi viene fatto in batchlearning, ovvero alla fine di tutte le epoch, per la rete neurale ricorrente e on-line, cio\`e alla fine di ogni epoch, per la rete neurale non ricorrente.
Sono stati utilizzati diversi valori di learning rate e di momentum, due parametri che influiscono su come la rete \`e allenata e, dopo diverse prove, sono stati utilizzati valori molto piccoli di entrambi.
\`E stata valutata l'ipotesi di usare l'algoritmo di BackPropagation Through Time, versione particolare del precedente adattata alle RNN, ma la complessit\`a dell'implementazione l'ha resa infattibile.\\
L'errore funzione di errore da minimizzare durante il la fase di train \`e quello dei minimi quadrati.



\newpage
\bibliographystyle{unsrt}
\bibliography{tesi}
\end{document}